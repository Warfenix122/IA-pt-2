(defvar *jogada* nil)

(defun negamax (no jogador &optional (profundidade 16) (alfa most-negative-fixnum) (beta most-positive-fixnum) (expandidos 1) (cortes 0))
  (cond 
    ((OR (no-solucaop no) (= profundidade 0)) (* jogador (no-heuristica no)))
    (t (let* ((sucessores (ordenar-nos (remove nil (sucessores no jogador)) jogador)))
      (negamax-aux no sucessores jogador profundidade alfa beta expandidos cortes)
      ))
    )
  )

(defun negamax-aux (no sucessores jogador profundidade alfa beta expandidos cortes)
  ;; (cond
  ;;  ((= (length sucessores) 1) (- (negamax (car sucessores) (- jogador) (1- profundidade) (- beta) (- alfa) (1+ expandidos) cortes)))
  ;;  (t (let* ((max-valor (max (no-heuristica no) (- (negamax (car sucessores) (- jogador) (1- profundidade) (- beta) (- alfa) (1+ expandidos) cortes))))
  ;;            (novo-alfa (max alfa max-valor))
  ;;            )
  ;;       (if (>= novo-alfa beta)
  ;;           (setq *jogada* (list (no-proxima-jogada (car sucessores)) expandidos (1+ cortes)))
  ;;         (negamax-aux no (cdr sucessores) jogador profundidade alfa beta expandidos cortes)
  ;;         )
  ;;       )
  ;;     )
  ;;  )
  (let* ((max-valor (max (no-heuristica no) (- (negamax (car sucessores) (- jogador) (1- profundidade) (- beta) (- alfa) (1+ expandidos) cortes))))
             (novo-alfa (max alfa max-valor))
             )
        (if (>= novo-alfa beta)
            (setq *jogada* (list (no-proxima-jogada (car sucessores)) expandidos (1+ cortes)))
          ;(negamax-aux no (cdr sucessores) jogador profundidade alfa beta expandidos cortes)
          )
        )
  )
 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;NOS;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun criar-no (tabuleiro &optional (profundidade 0) (pai nil) (valor-f most-negative-fixnum) jogador)
    (list tabuleiro profundidade valor-f pai jogador)
)

(defun novo-sucessor (lin col peca no fnHeuristica pred jogador)
  (let* ((profundidade (1+ (no-profundidade no)))
        (heuristica (funcall fnHeuristica lin col (tabuleiro (no-estado no)) peca))
        )
    (cond 
     ((equal (funcall pred lin col peca (no-estado no)) NIL) NIL)
     (t (criar-no (funcall pred lin col peca (no-estado no)) profundidade no heuristica jogador))
     )
   )
  )

(defun no-teste ()
  (criar-no (jogo-teste-2) 0 nil 0 -1)
)

(defun recalcular-h (no jogador)
  (substituir-valor no 2 (* jogador (no-heuristica no)))
)

(defun substituir-valor (lista n valor)
  (cond ((null lista) NIL)
        ((equal n 0) (cons valor (cdr lista)))
        (T (cons (car lista) (substituir-valor (cdr lista) (- n 1) valor)))))

(defun inverter-h (no)
  (substituir-valor no 2 (- (no-heuristica no)))
)

(defun compara-h (no-a no-b)
  (let ((h-a (no-heuristica no-a))
        (h-b (no-heuristica no-b))
       )
    (cond 
      ((> h-a h-b) no-a)
      (t no-b)
    )
  )
)

(defun no-inicial ()
  (criar-no (tabuleiro-jogo))
)

(defun cria-solucao(no-jogada nos-analisados nos-cortados &optional tempo-inicial)
  ;(list no-jogada nos-analisados nos-cortados (obter-tempo-gasto tempo-inicial))
  (list no-jogada nos-analisados nos-cortados)
)

(defun obter-jogada-solucao(no-solucao)
  (first no-solucao)
)

(defun obter-tempo-gasto(tempo-inicial)
  (- (get-universal-time) tempo-inicial)
)


(defun obter-expandidos(no-solucao)
   (second no-solucao)
)


(defun obter-nr-cortes(no-solucao)
   (third no-solucao)
)


(defun obter-tempo-gasto-solucao(no-solucao)
  (fourth no-solucao)
)

(defun no-proxima-jogada (no)
  (cond 
    ((equal (no-pai (no-pai no)) nil) no)
    (t (no-pai no))
  )
)

(defun no-estado (no)
    (first no)
)

(defun no-profundidade (no)
    (second no)
)

(defun no-heuristica (no)
    (third no)
)

(defun no-pai (no)
    (fourth no)
)

(defun no-jogador (no)
  (fifth no)
)

(defun no-solucaop (no)
  (cond
   ((not no) nil)
   (t (let* ((tabuleiro (tabuleiro (no-estado no)))
             (venceu (venceup tabuleiro))
             )
        (if (equal venceu t) t nil)
        )
      )
   )
)

(defun no-existep (no lista-nos algoritmo)
  "Verifica se o estado existe na lista passada no argumento"
  (cond 
   ((null lista-nos) no)
   ((and (eq algoritmo 'a*) (estadop (no-estado no) (no-estado (car lista-nos))) (= (no-heuristica no) (no-heuristica (car lista-nos)))) NIL)
   ((estadop (no-estado no) (no-estado (car lista-nos))) NIL)
   (t (no-existep no (cdr lista-nos) algoritmo))
   )
)

(defun estadop (estado1 estado2)
  "Compara dois estados"
  (cond
   ((and (equal (tabuleiro estado1) (tabuleiro estado2)) (equal (reserva estado1) (reserva estado2))) T)
   (T NIL)
   )
)

(defun sucessores (no jogador)
  (let* ((posicoes (posicoes))
          (sucessores (por-pecas-posicao no posicoes 'p
 jogador))
              (sucessores-possiveis (remove nil (mapcar #'(lambda (sucessor)
                                                            (cond 
                                                             ((and (estadop (no-estado no) (no-estado sucessor)) (> (no-heuristica sucessor) (no-heuristica no)))NIL)
                                                             (T sucessor)
                                                             )
                                                            )sucessores)))
              )sucessores-possiveis)
  
  )

(defun por-pecas-posicao (no posicoes fnHeuristica jogador &optional (sucessores-aux '()) )
    (cond
      ((null posicoes) sucessores-aux)
      (T (let* ((coordenadas (car posicoes))
                (pecas (remove 0 (reserva (no-estado no))))
                (sucessores (remove nil(mapcar #'(lambda (peca)
                                                   (novo-sucessor (first coordenadas) (second coordenadas) peca no fnHeuristica 'operador jogador)
                                                   ;; (cond
                                                   ;;  ((eq algoritmo 'a*) (novo-sucessor-a* (first coordenadas) (second coordenadas) peca no fnHeuristica 'operador))
                                                   ;;  (t (novo-sucessor (first coordenadas) (second coordenadas) peca no 'operador))
                                                   ;;  )
                                                   ) pecas))))
           (por-pecas-posicao no (cdr posicoes) fnHeuristica jogador (append sucessores-aux sucessores))
      )
    )
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;HEURISTICA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun heuristica-enunciado (lin col estado peca)
  (let ((p (p lin col (tabuleiro estado) peca)))
      (cond
       ((not p) nil)
       (t (- 4 p))
       )
      )
  )

(defun avalia-jogada (estado lin col peca jogador)
  ;; (cond 
  ;;  ((equal jogador 1) (let* ((linha (linha lin (tabuleiro estado)))
  ;;                            (coluna (coluna col (tabuleiro estado)))
  ;;                            (linha-semelhancas (conta-semelhancas linha peca))
  ;;                            (coluna-semelhancas (conta-semelhancas coluna peca))
  ;;                            )
  ;;                            (cond 
  ;;                             ((= lin col) (if (or (= linha-semelhancas 1) (= coluna-semelhancas 1) (= (conta-semelhancas (diagonal1 tabuleiro) peca) 1))))
  ;;                             ((= (- 3 lin) col) )
  ;;                             (t )
  ;;                           )
                          
  ;;                         ))   ;;;Joga MAX
  ;;  (t) ;;;;; Joga Min
  ;;  )
  (let* ((p-jogada (p lin col estado peca)))
          (cond 
            ((= p-jogada 1) (* jogador 10))
            ((= p-jogada 2) (* jogador 20))
            ((= p-jogada 3) (* (- jogador) 100))
            ((= p-jogada 4) (* jogador 100))
        )
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SORTING;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun ordenar-nos (lista-nos jogador)
  "Quick sort da lista de nos, faz sort crescente dependendo do f calculado"
  (cond
    ((null lista-nos) nil)
    ((= jogador 1)
      (append
        (ordenar-nos (lista>= (car lista-nos) (cdr lista-nos)) jogador)
        (cons (car lista-nos) nil) 
        (ordenar-nos (lista< (car lista-nos) (cdr lista-nos)) jogador))
    )
    (t (append
        (ordenar-nos (lista< (car lista-nos) (cdr lista-nos))jogador)
        (cons (car lista-nos) nil) 
        (ordenar-nos (lista>= (car lista-nos) (cdr lista-nos))jogador)))
  )
)

(defun lista< (a b)
  (cond
    ((or (null a) (null b)) nil)
    ((< (no-heuristica a) (no-heuristica (car b))) (lista< a (cdr b)))
    (t (cons (car b) (lista< a (cdr b))))
  )
)

(defun lista>= (a b)
  (cond
    ((or (null a) (null b)) nil)
    ((>= (no-heuristica a) (no-heuristica (car b))) (lista>= a (cdr b)))
    (t (cons (car b) (lista>= a (cdr b))))
  )
)

(defun retirar-no-lista (no lista-nos)
  (cond
    ((null lista-nos) nil)
    ((estadop (no-estado no) (no-estado (car lista-nos))) (cons nil (retirar-no-lista no (cdr lista-nos))))
    (t (cons (car lista-nos) (retirar-no-lista no (cdr lista-nos))))
  )
)
